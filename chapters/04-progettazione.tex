\chapter{Progettazione ed implementazione}
\label{cap:progettazione}

\intro{In questo capitolo si descrive il workflow del modulo sviluppato, le scelte di progettazione ed i dettagli di implementazione del modulo di autenticazione sviluppato.}\\

% ================================================================= %
\section{Progettazione}

\paragraph{Premessa e Workflow.}
Essendo una prima versione sperimentale, questo metodo di autenticazione, come del resto OpenVLC, è stato progettato per una comunicazione \gls{p2p}\glsfirstoccur e assume che i due nodi abbiano già stabilito una connessione.
Il workflow consiste in due passi: il trasmettitore, in fase di invio dei dati, calcola una \gls{otp} e la incorpora in una posizione nota nei segnali fisici del pacchetto; il ricevitore, in fase di ricezione, estrae la \gls{otp} dai segnali fisici del pacchetto e ne verifica la validità.\\
I pacchetti che non presentano una valida \gls{otp} vengono scartati, altrimenti possono procedere ad ulteriori elaborazioni da parte di OpenVLC.


\subsection{Generazione e verifica dell'OTP}
Una \gls{otp} è un codice di autenticazione temporaneo, specifico per dispositivo in quanto involve una chiave segreta, valido per una sola operazione o comunque per un breve periodo di tempo.

\paragraph{Generazione.}
La formula utilizzata dal trasmettitore per la generazione della \gls{otp} è la seguente:
\begin{equation}
    \text{POTP}(K, T, SN, \text{src-addr}) = \text{Truncate}\left( \text{HMAC}(K, T, SN, \text{src-addr}) \right)
    \label{eq:potp}
\end{equation}
in cui K denota la \gls{psk}, cioè la chiave segreta precondivisa tra le due schede; T è un numero intero che rappresenta l'intervallo di tempo nel quale la \gls{otp} è valida; SN è un \textit{sequence number} incrementale; src-addr rappresenta l'indirizzo MAC del dispositivo trasmettitore.

La sicurezza di questo tipo di \gls{otp} risiede proprio nella sua dipendenza da diversi parametri. Infatti richiede ai dispositivi la conoscenza della chiave K, scade una volta concluso il periodo di tempo T, può essere utilizzata un'unica volta a causa del SN ed è strettamente legata al dispositivo grazie al src-addr.

\paragraph{Lunghezza.}
Per essere resistente ad attacchi \textit{brute force}, una \gls{otp} deve avere una lunghezza di almeno 31 bit; naturalmente maggiore è la dimensione della \gls{otp} e maggiore è la latenza introdotta nella comunicazione.\\
Considerato ciò, si è deciso di utilizzare una \gls{otp} di lunghezza 32 byte, in modo tale che fosse abbastanza resistente agli attacchi ma senza introdurre rallentamenti percepibili nella comunicazione.\\
La funzione Truncate, com'è intuibile, troncherà l'output della funzione HMAC a tale lunghezza.

\paragraph{HMAC.}
La funzione \gls{hmac}, è un meccanismo crittografico che consente di verificare l'integrità e l'autenticità di un messaggio. In questo contesto, HMAC viene utilizzato per generare la \gls{otp} combinando la chiave segreta K con i parametri T, SN e src-addr tramite una funzione di hash sicura. Il risultato è un codice che può essere calcolato solo da chi possiede la chiave K e che varia in base ai parametri forniti, garantendo così che ogni \gls{otp} sia unica e valida solo per una specifica trasmissione e intervallo temporale.

\paragraph{Time-step T.}
Il time-step T è un numero intero che rappresenta il numero di intervalli di tempo (\textit{time-step}) di durata X trascorsi tra $T_0$ e l'attuale tempo unix. Viene calcolato tramite la seguente formula:
\begin{equation}
    T = \frac{\text{current Unix time} - T_0}{X}
    \label{eq:timestep}
\end{equation}
in cui \textit{current Unix time} indica i secondi trascorsi a partire dall'epoch Unix, $T_0$ è un riferimento ad un tempo iniziale arbitrario ed X indica l'intervallo di tempo di validità della \gls{otp}. $T_0$ e X devono avere lo stesso valore in entrambi i dispositivi.
Nel caso specifico di questo progetto, X è stato impostato a 3, quindi ogni \gls{otp} è valida per un massimo di tre secondi.

\paragraph{Chiave Segreta K.}
Come già anticipato, K è una chiave segreta precondivisa tra trasmettitore e ricevitore. In questo progetto ha lunghezza di 128 bit.

\paragraph{Sequence Number SN.}
SN è un numero intero che incrementa ad ogni \gls{otp} generata in un determinato periodo di tempo. Trascorso quel periodo di tempo, infatti, viene azzerato nuovamente.\\
Il SN è un componente fondamentale in quanto è solo grazie ad esso che la \gls{otp} è valida per un solo utilizzo. Infatti il ricevitore, in un determinato intervallo di tempo, salva in memoria il SN più alto ricevuto e non accetta pacchetti con SN minore o uguale ad esso.\\
Se tale componente non fosse presente, ogni \gls{otp} sarebbe valida per un intero intervallo di tempo, in questo caso tre secondi, e la protezione contro \textit{replay attacks} sarebbe notevolmente inficiata.

\paragraph{Verifica.}
Il ricevitore, nel processo di verifica della \gls{otp}, genera una \gls{otp} attesa tramite la medesima funzione di generazione utilizzata dal trasmettitore (equazione \ref{eq:potp}) e la confronta con quella ricevuta.\\
Come parametri per la funzione, vengono usati dei valori attesi, ad esempio, il ricevitore si aspetta che la \gls{otp} ricevuta sia stata generata con il SN successivo a quello dell'ultimo pacchetto ricevuto.

In realtà, non viene generata una singola \gls{otp}, bensì un insieme di \gls{otp} da considerare valide, in quanto si è voluto introdurre un certo grado di flessibilità, in modo tale da migliorare la resilienza del sistema ad eventuali ritardi nella comunicazione o perdite di pacchetti.\\
Siano $T_c$ e $SN_c$ rispettivamente l'intervallo di tempo corrente e il prossimo SN atteso, siano x ed y rispettivamente il grado di flessibilità per T ed il grado di flessibilità per SN; vengono considerate valide tutte le \gls{otp} generate con l'equazione \ref{eq:potp} in cui $T \in [T_c - x, T_c]$ e $SN \in [SN_c, SN_c + y]$.\\
Infatti, si supponga che un pacchetto venga trasmesso con un ritardo superiore al time step; quel pacchetto, sebbene legittimo, verrebbe considerato dal ricevitore come illegittimo. Allo stesso modo, supponendo che vengano persi alcuni pacchetti, se non fosse stata introdotta questa flessibilità, tutti i successivi (fino al successivo time step) verrebbero considerati erroneamente illegittimi.


\subsection{Codifica e decodifica dell'OTP}

\paragraph{Embedding ed Estrazione.}
Per inglobare la \gls{otp} all'interno dei segnali fisici di ogni pacchetto, si è deciso di usare l'operatore logico \gls{xor}.\\
La particolarità dello \gls{xor} è che consente di "fondere" l'informazione dell'OTP con i segnali fisici del pacchetto in modo reversibile, grazie alla proprietà di auto-invertibilità dello XOR. Secondo questa proprietà, dato un messaggio \( M \) e una chiave \( K \), se \( C = M \oplus K \), allora risulta sempre valido che \( M = C \oplus K \).

Il trasmettitore, infatti, applica l'operazione di \gls{xor} tra la sequenza di byte dell'OTP ed i quattro byte del \textit{frame header} contenenti gli indirizzi di trasmettitore e ricevitore (figura \ref{fig:phy_frame_structure}, campi Destination e Source), ottenendo una sequenza modificata che viene inserita nel pacchetto. Al ricevitore, la stessa operazione di \gls{xor} tra la sequenza ricevuta e la porzione nota del payload permette di recuperare l'OTP originale.

Questa tecnica garantisce che l'OTP sia trasmessa in modo non direttamente leggibile, aumentando la sicurezza contro attacchi di intercettazione. Inoltre, l'operazione di \gls{xor} è computazionalmente leggera e non introduce latenza significativa nella comunicazione.

La posizione e la lunghezza della porzione di frame utilizzata per l'operazione di \gls{xor} sono concordate tra trasmettitore e ricevitore, inoltre in una comunicazione \gls{p2p} gli indirizzi Destinatione e Source sono noti ad entrambi. Ciò permette una corretta estrazione e verifica dell'OTP.


% ================================================================= %
\section{Implementazione}
% spiega tutto quello che hai fatto testbed codice modificato (motivazione scelte)






Il codice sviluppato è tracciato nella repository del progetto nel branch PhyAuthP2P: \cite{site:openvlc-pa-github}.
